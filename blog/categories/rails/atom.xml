<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Tumayun's Blog]]></title>
  <link href="http://tumayun.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://tumayun.com/"/>
  <updated>2013-06-30T11:37:30+08:00</updated>
  <id>http://tumayun.com/</id>
  <author>
    <name><![CDATA[tumayun]]></name>
    <email><![CDATA[tumayun.2010@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails 4 源码阅读之timestamps]]></title>
    <link href="http://tumayun.com/blog/2013-06-29/rails-4-yuan-ma-yue-du-zhi-updated-ayu-created-at/"/>
    <updated>2013-06-29T19:20:00+08:00</updated>
    <id>http://tumayun.com/blog/2013-06-29/rails-4-yuan-ma-yue-du-zhi-updated-ayu-created-at</id>
    <content type="html"><![CDATA[<p>最近开始看 Rails 4 的源码,打算写一系列的 Rails 4 源码阅读的文章,这是第一篇.</p>

<p>我是因为想知道 Rails 4 里面的 timestamps 是在什么时候赋值或者更新的,然后我翻看了下 Rails 4 的 ActiveRecord 代码.</p>

<p>在<a href="https://github.com/rails/rails/blob/master/activerecord/lib/active_record/timestamp.rb">https://github.com/rails/rails/blob/master/activerecord/lib/active_record/timestamp.rb</a>里面有<a href="https://github.com/rails/rails/blob/master/activerecord/lib/active_record/timestamp.rb#L46">create_record</a>和<a href="https://github.com/rails/rails/blob/master/activerecord/lib/active_record/timestamp.rb#L60">update_record</a>方法,更新这些<code>timestamps</code>的操作就在这个里面了.</p>

<p>恩,应该是这样.<code>update_record</code>与<code>create_record</code>分别是创建和更新必掉的方法,所以如果有 timestamps 并且开启了<code>record_timestamps</code>就会去赋值或者更新这些字段了.</p>

<p>其实也可以从<code>save</code>开始阅读,<code>save</code>的过程可以简化成这样.</p>

<p>```ruby</p>

<h1>https://github.com/rails/rails/blob/master/activerecord/lib/active_record//connection_adapters/abstract/transaction.rb#L270</h1>

<p>def save(*) #:nodoc:
  rollback_active_record_state! do</p>

<pre><code>with_transaction_returning_status { super }
</code></pre>

<p>  end
end
.
.
.</p>

<h1>https://github.com/rails/rails/blob/master/activerecord/lib/active_record/attribute_methods/dirty.rb#L31</h1>

<p>def save(*)
  if status = super</p>

<pre><code>@previously_changed = changes
@changed_attributes.clear
</code></pre>

<p>  end
  status
end
.
.
.</p>

<h1>https://github.com/rails/rails/blob/master/activerecord/lib/active_record/validations.rb#L56</h1>

<p>def save(options={})
  perform_validations(options) ? super : false
end
.
.
.</p>

<h1>https://github.com/rails/rails/tree/master/activerecord/lib/activerecord/persistence.rb#L105</h1>

<p>def save(*)
  create_or_update
rescue ActiveRecord::RecordInvalid
  false
end
.
.
.</p>

<h1>https://github.com/rails/rails/tree/master/activerecord/lib/activerecord/callbacks.rb#L298</h1>

<p>def create_or_update #:nodoc:
  run_callbacks(:save) { super }
end
.
.
.</p>

<h1>https://github.com/rails/rails/tree/master/activerecord/lib/activerecord/persistence.rb#L464</h1>

<p>def create_or_update
  raise ReadOnlyRecord if readonly?
  result = new_record? ? create_record : update_record
  result != false
end
.
.
.</p>

<h1>https://github.com/rails/rails/blob/master/activerecord/lib/active_record/timestamp.rb#L46</h1>

<p>def create_record
  if self.record_timestamps</p>

<pre><code>current_time = current_time_from_proper_timezone

all_timestamp_attributes.each do |column|
  if respond_to?(column) &amp;&amp; respond_to?("#{column}=") &amp;&amp; self.send(column).nil?
    write_attribute(column.to_s, current_time)
  end
end
</code></pre>

<p>  end</p>

<p>  super
end
.
.
.</p>

<h1>https://github.com/rails/rails/blob/master/activerecord/lib/active_record/callbacks.rb#L302</h1>

<p>def create_record #:nodoc:
  run_callbacks(:create) { super }
end
.
.
.</p>

<h1>https://github.com/rails/rails/blob/master/activerecord/lib/active_record/persistence.rb#L483</h1>

<p>def create_record(attribute_names = @attributes.keys)
  attributes_values = arel_attributes_with_values_for_create(attribute_names)</p>

<p>  new_id = self.class.unscoped.insert attributes_values
  self.id ||= new_id if self.class.primary_key</p>

<p>  @new_record = false
  id
end
```</p>

<p>哇,就是这样的顺序,但是感觉有点复杂啊,<code>save</code>到处都是,通过<code>super</code>关键字逐层调用,就像一个<code>rack stack</code>一样!最主要的是我们要知道<code>save</code>的调用链是怎么样的,这个可以看<code>ActiveRecord::Base.ancestors</code>.</p>

<p><code>ruby
puts ActiveRecord::Base.ancestors.join("\n")
ActiveRecord::Base
ActiveRecord::Core
ActiveRecord::Store
ActiveRecord::Serialization
ActiveModel::Serializers::Xml
ActiveModel::Serializers::JSON
ActiveModel::Serialization
ActiveRecord::Reflection
ActiveRecord::Transactions
ActiveRecord::Aggregations
ActiveRecord::NestedAttributes
ActiveRecord::AutosaveAssociation
ActiveModel::SecurePassword
ActiveRecord::Associations
ActiveRecord::Timestamp
ActiveModel::Validations::Callbacks
ActiveRecord::Callbacks
ActiveRecord::AttributeMethods::Serialization
ActiveRecord::AttributeMethods::Dirty
ActiveModel::Dirty
ActiveRecord::AttributeMethods::TimeZoneConversion
ActiveRecord::AttributeMethods::PrimaryKey
ActiveRecord::AttributeMethods::Query
ActiveRecord::AttributeMethods::BeforeTypeCast
ActiveRecord::AttributeMethods::Write
ActiveRecord::AttributeMethods::Read
ActiveRecord::AttributeMethods
ActiveModel::AttributeMethods
ActiveRecord::Locking::Pessimistic
ActiveRecord::Locking::Optimistic
ActiveRecord::CounterCache
ActiveRecord::Validations
ActiveModel::Validations::HelperMethods
ActiveSupport::Callbacks
ActiveModel::Validations
ActiveRecord::Integration
ActiveModel::Conversion
ActiveRecord::AttributeAssignment
ActiveModel::ForbiddenAttributesProtection
ActiveModel::DeprecatedMassAssignmentSecurity
ActiveRecord::Sanitization
ActiveRecord::Scoping::Named
ActiveRecord::Scoping::Default
ActiveRecord::Scoping
ActiveRecord::Inheritance
ActiveRecord::ModelSchema
ActiveRecord::ReadonlyAttributes
ActiveRecord::Persistence
Object
JSON::Ext::Generator::GeneratorMethods::Object
ActiveSupport::Dependencies::Loadable
PP::ObjectMixin
Kernel
BasicObject
</code>
这样就能知道调用链的情况了.当然还可以去<code>debugger</code>.</p>

<p>恩,<code>save</code>就是这样!<code>timestamps</code>又明白了,太棒了~!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Resque 数据库链接错误]]></title>
    <link href="http://tumayun.com/blog/2013-01-25/resque-shu-ju-ku-lian-jie-cuo-wu/"/>
    <updated>2013-01-25T14:07:00+08:00</updated>
    <id>http://tumayun.com/blog/2013-01-25/resque-shu-ju-ku-lian-jie-cuo-wu</id>
    <content type="html"><![CDATA[<p>  &nbsp;&nbsp;最近项目用的 <a href="https://github.com/defunkt/resque," title="Resque Github">Resque</a> 老是会有一些莫名其妙的问题，非常头疼！
<code>ruby
Mysql::Error: MySQL server has gone away: SHOW FIELDS FROM `deals`
</code>
  实在是没办法了，然后仔细的去阅读了下 <a href="https://github.com/defunkt/resque," title="Resque Github">Resque</a> 的 <a href="https://github.com/defunkt/resque/wiki," title="Resque wiki">wiki</a>，有种恍然大悟的感觉。
  原来我遇到的问题大家都遇到过，并且给出了解决方案，就拿 Resque 数据库链接错误来说，<a href="https://github.com/defunkt/resque#mysqlerror-mysql-server-has-gone-away," title="Resque Github">Resque</a> 原作者已经有了推荐的解决方案，原文如下：<br/>
  &nbsp;&nbsp;If your workers remain idle for too long they may lose their MySQL connection.
  If that happens we recommend using <a href="https://gist.github.com/238999">this Gist</a>.<br/>
  &nbsp;&nbsp;然后我在项目 <code>config/initializers</code> 目录中的 <code>resque.rb</code> 文件中加入代码：
<code>ruby
Resque.after_fork do |job|
  ActiveRecord::Base.connection_handler.verify_active_connections!
end
</code>
问题就这样解决了！但是，引入一个 <code>Gem</code>，我连文档都没有仔细阅读，匆匆使用了事，现在想想真的很惭愧！
以后引入 <code>Gem</code> 最起码要将文档通读一边，有能力更应该通读源码！<br/>
谨记！</p>
]]></content>
  </entry>
  
</feed>
